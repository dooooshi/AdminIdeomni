# Backend Response Standards & User Experience Guidelines

This rule ensures proper handling of backend API responses to create optimal user experiences across the Ideomni platform.

## üåê API Configuration

### Base URLs & Documentation
- **Development**: `http://localhost:2999/api`
- **Production**: `https://your-domain.com/api`
- **Swagger UI**: `http://localhost:2999/docs`

## üìä Standard Response Handling

### Response Type Definitions
Always use these TypeScript interfaces for type safety:

```typescript
interface ApiResponse<T> {
  success: boolean;
  data: T;
  message: string;
  businessCode: number;
  timestamp: string;
  path: string;
  extra?: {
    version: string;
    [key: string]: any;
  };
}

interface ErrorResponse {
  success: false;
  data: null;
  message: string;
  businessCode: number;
  timestamp: string;
  path: string;
  details?: {
    field?: string;
    validationErrors?: string[];
    [key: string]: any;
  };
}
```

### Universal Error Handling Pattern
Implement this error handling utility in your components:

```typescript
class ErrorHandler {
  static handle(error: ErrorResponse): string {
    switch (error.businessCode) {
      // Authentication errors (2000-2999)
      case 2010:
      case 2100:
        return 'Invalid username or password';
      case 2011:
      case 2101:
        return 'Session expired. Please login again';
      case 2016:
      case 2106:
        return 'You do not have permission to perform this action';
      
      // Validation errors (3000-3999)
      case 3000:
        return error.details?.validationErrors?.join(', ') || 'Invalid input';
      case 3002:
        return `Missing required field: ${error.details?.field || 'unknown'}`;
      
      // Business errors (4000-4999)
      case 4001:
        return 'Resource not found';
      case 4002:
        return 'Resource already exists';
      
      // System errors (1000-1999)
      case 1000:
      case 1002:
        return 'System error. Please try again later';
      
      case 5001:
        return 'Too many requests. Please wait and try again';
      
      default:
        return error.message || 'An unexpected error occurred';
    }
  }

  static isAuthError(businessCode: number): boolean {
    return businessCode >= 2000 && businessCode < 3000;
  }

  static shouldRetry(businessCode: number): boolean {
    return businessCode === 1000 || businessCode === 4004;
  }
}
```

## üîê Authentication Integration

### JWT Token Management
Always implement automatic token refresh:

```typescript
class ApiClient {
  private baseURL = process.env.NODE_ENV === 'development' 
    ? 'http://localhost:2999/api' 
    : 'https://your-domain.com/api';
  
  async request<T>(
    endpoint: string, 
    options: RequestInit = {},
    language: string = 'en'
  ): Promise<ApiResponse<T>> {
    const headers = {
      'Content-Type': 'application/json',
      'Accept-Language': language,
      'X-Lang': language,
      ...options.headers
    };

    // Add authentication if available
    const accessToken = getAccessToken(); // Your token getter
    if (accessToken) {
      headers['Authorization'] = `Bearer ${accessToken}`;
    }

    const response = await fetch(`${this.baseURL}${endpoint}`, {
      ...options,
      headers
    });

    const data = await response.json();

    // Handle token refresh for expired tokens
    if (data.businessCode === 2011 || data.businessCode === 2101) {
      await this.refreshTokens();
      // Retry with new token
      headers['Authorization'] = `Bearer ${getAccessToken()}`;
      const retryResponse = await fetch(`${this.baseURL}${endpoint}`, {
        ...options,
        headers
      });
      return retryResponse.json();
    }

    return data;
  }
}
```

## üåê Internationalization Support

### Language Preference Implementation
Always support multiple languages with proper fallback:

```typescript
// Language resolution order:
// 1. Query parameter: ?lang=en
// 2. Accept-Language header
// 3. Custom X-Lang header
// 4. Browser default
// 5. Fallback to Chinese (zh)

const fetchWithLanguage = async (url: string, options = {}, language = 'en') => {
  const headers = {
    ...options.headers,
    'Accept-Language': language,
    'X-Lang': language
  };
  
  return fetch(url, { ...options, headers });
};
```

## üõ†Ô∏è React Hook Pattern

### Standard API Hook Implementation
Use this pattern for all API interactions:

```typescript
import { useState, useCallback } from 'react';
import { useI18n } from '@i18n/hooks/useI18n'; // Use existing i18n system

interface UseApiState<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
  success: boolean;
}

function useApi<T>() {
  const [state, setState] = useState<UseApiState<T>>({
    data: null,
    loading: false,
    error: null,
    success: false
  });

  const { language } = useI18n(); // Get current language from context
  const apiClient = new ApiClient();

  const execute = useCallback(async (
    endpoint: string,
    options?: RequestInit
  ) => {
    setState(prev => ({ ...prev, loading: true, error: null, success: false }));

    try {
      const response = await apiClient.request<T>(endpoint, options, language);
      
      if (response.success) {
        setState({
          data: response.data,
          loading: false,
          error: null,
          success: true
        });
        return response.data;
      } else {
        const errorMessage = ErrorHandler.handle(response);
        setState({
          data: null,
          loading: false,
          error: errorMessage,
          success: false
        });
        
        // Handle auth errors by redirecting
        if (ErrorHandler.isAuthError(response.businessCode)) {
          // Redirect to appropriate login page
          window.location.href = response.businessCode >= 2100 ? '/sign-in' : '/admin/sign-in';
        }
      }
    } catch (err) {
      setState({
        data: null,
        loading: false,
        error: 'Network error. Please check your connection.',
        success: false
      });
    }
  }, [apiClient, language]);

  const reset = useCallback(() => {
    setState({
      data: null,
      loading: false,
      error: null,
      success: false
    });
  }, []);

  return { ...state, execute, reset };
}
```

## üéØ User Experience Best Practices

### 1. Loading States
Always provide meaningful loading indicators:

```typescript
function UserProfile() {
  const { data: user, loading, error, execute } = useApi<User>();
  const { t } = useI18n();

  useEffect(() => {
    execute('/user/profile');
  }, [execute]);

  if (loading) return <IdeomniLoading message={t('LOADING_PROFILE')} />;
  if (error) return <IdeomniMessage type="error" message={error} />;
  if (!user) return null;

  return <div>Welcome, {user.firstName}!</div>;
}
```

### 2. Error Feedback
Use [IdeomniMessage](mdc:src/@ideomni/core/IdeomniMessage/index.ts) for consistent error display:

```typescript
// For form validation errors
if (response.businessCode === 3000 && response.details?.validationErrors) {
  response.details.validationErrors.forEach(error => {
    showMessage({
      type: 'error',
      message: error,
      autoClose: true
    });
  });
}

// For success operations
if (response.success) {
  showMessage({
    type: 'success',
    message: t('OPERATION_SUCCESS'),
    autoClose: true
  });
}
```

### 3. Optimistic Updates
Implement optimistic UI updates for better perceived performance:

```typescript
const updateUserProfile = async (userId: string, updates: Partial<User>) => {
  // Show immediate feedback
  setUser(current => ({ ...current, ...updates }));
  showMessage({ type: 'info', message: t('SAVING_CHANGES') });

  try {
    const response = await apiClient.request<User>(
      `/user/${userId}`,
      { method: 'PUT', body: JSON.stringify(updates) }
    );

    if (response.success) {
      setUser(response.data);
      showMessage({ type: 'success', message: t('CHANGES_SAVED') });
    } else {
      // Revert optimistic update
      setUser(originalUser);
      throw new Error(response.message);
    }
  } catch (error) {
    setUser(originalUser);
    showMessage({ type: 'error', message: error.message });
  }
};
```

### 4. Pagination Handling
For paginated responses, provide smooth navigation:

```typescript
interface PaginatedResponse<T> {
  items: T[];
  totalCount: number;
  currentPage: number;
  totalPages: number;
  pageSize: number;
}

const usePaginatedApi = <T>() => {
  const [pagination, setPagination] = useState({
    page: 1,
    pageSize: 20,
    search: ''
  });

  const { data, loading, error, execute } = useApi<PaginatedResponse<T>>();

  const loadPage = useCallback((page: number) => {
    setPagination(prev => ({ ...prev, page }));
    execute(`/endpoint?page=${page}&pageSize=${pagination.pageSize}&search=${pagination.search}`);
  }, [execute, pagination.pageSize, pagination.search]);

  return { data, loading, error, pagination, loadPage };
};
```

## üîÑ File Upload Pattern

### Progress-Aware Upload Implementation
```typescript
const uploadFile = async (
  file: File, 
  onProgress?: (progress: number) => void
): Promise<{url: string}> => {
  const formData = new FormData();
  formData.append('file', file);

  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    
    xhr.upload.onprogress = (e) => {
      if (e.lengthComputable && onProgress) {
        onProgress(Math.round((e.loaded / e.total) * 100));
      }
    };

    xhr.onload = () => {
      const response = JSON.parse(xhr.responseText);
      if (response.success) {
        resolve(response.data);
      } else {
        reject(new Error(ErrorHandler.handle(response)));
      }
    };

    xhr.onerror = () => reject(new Error('Upload failed'));

    xhr.open('POST', `${baseURL}/files/upload`);
    xhr.setRequestHeader('Authorization', `Bearer ${getAccessToken()}`);
    xhr.send(formData);
  });
};
```

## üîç Development & Debugging

### Enhanced Logging (Development Only)
```typescript
const isDevelopment = process.env.NODE_ENV === 'development';

if (isDevelopment) {
  // Log all API requests/responses
  console.group(`üåê API ${options.method || 'GET'} ${endpoint}`);
  console.log('Request:', { headers: options.headers, body: options.body });
  console.log('Response:', { success: response.success, businessCode: response.businessCode });
  if (!response.success) console.error('Error:', response.message);
  console.groupEnd();
}
```

## üìã Mandatory Checklist

For every API integration, ensure:

- [ ] **Type Safety**: Use proper TypeScript interfaces
- [ ] **Error Handling**: Implement ErrorHandler.handle()
- [ ] **Loading States**: Show appropriate loading indicators
- [ ] **Success Feedback**: Provide confirmation messages
- [ ] **Language Support**: Use current language from [useI18n](mdc:src/@i18n/hooks/useI18n.ts)
- [ ] **Authentication**: Handle token refresh automatically
- [ ] **Retry Logic**: Implement for retryable errors
- [ ] **Optimistic Updates**: For better perceived performance
- [ ] **Validation**: Show specific field errors from API
- [ ] **Accessibility**: Ensure error messages are announced to screen readers

## üé® UI Component Integration

### Use Existing Ideomni Components
- **Loading**: [IdeomniLoading](mdc:src/@ideomni/core/IdeomniLoading/index.ts)
- **Messages**: [IdeomniMessage](mdc:src/@ideomni/core/IdeomniMessage/index.ts)
- **Dialogs**: [IdeomniDialog](mdc:src/@ideomni/core/IdeomniDialog/index.ts)
- **Layout**: [IdeomniPageCarded](mdc:src/@ideomni/core/IdeomniPageCarded/index.ts) or [IdeomniPageSimple](mdc:src/@ideomni/core/IdeomniPageSimple/index.ts)

### Error Boundaries
Wrap API-heavy components in error boundaries to gracefully handle failures:

```typescript
import { ErrorBoundary } from '@ideomni/utils/ErrorBoundary';

<ErrorBoundary fallback={<ErrorFallback />}>
  <YourApiComponent />
</ErrorBoundary>
```

## üöÄ Performance Optimization

### Response Caching
Implement intelligent caching for frequently accessed data:

```typescript
// Cache responses based on endpoint and parameters
const responseCache = new Map<string, {data: any, timestamp: number}>();
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

const getCachedResponse = (key: string) => {
  const cached = responseCache.get(key);
  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
    return cached.data;
  }
  return null;
};
```

Remember: Always prioritize user experience by providing immediate feedback, clear error messages, and smooth interactions. Use the existing [Ideomni component system](mdc:src/@ideomni/) for consistency across the platform.
alwaysApply: true
---
